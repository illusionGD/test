<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>vue-origin</title>
    </head>
    <body>
        <div class="test"></div>
    </body>
    <script>
        const weakMap = new WeakMap() // 存储全部监听的对象
        const effectStack = [] // 副作用函数栈，解决effect嵌套导致的副作用函数绑定错误的问题呢，每次从栈中弹出的fn就是正确的副作用函数
        let test = 1

        const data = new Proxy(
            {
                info: '1',
                ok: true,
            },
            {
                get(target, key) {
                    const activeEffect = effectStack.pop()
                    if (!activeEffect) {
                        return target[key]
                    }
                    // 获取该对象的map
                    let map = weakMap.get(target)

                    // 如果该对象是第一次监听，则新建map，并存起来
                    if (!map) {
                        map = new Map()
                        weakMap.set(target, map)
                    }

                    let bucket = map.get(key)

                    // 如果桶不存在，则新建对应key的桶，并存起来
                    if (!bucket) {
                        map.set(key, (bucket = new Set()))
                    }

                    bucket.add(activeEffect)

                    // 收集副作用函数绑定的set桶
                    activeEffect.buckets.push(bucket)

                    return target[key]
                },
                set(target, key, newVal, oldVal) {
                    console.log('set')
                    target[key] = newVal
                    // 取出对象的map
                    const map = weakMap.get(target)
                    if (!map) return true
                    // 取出对应key的桶
                    const bucket = map.get(key)

                    // 执行桶中全部副作用函数
                    if (bucket) {
                        // new set的原因：因为原理的set中，正在清除fn（副作用函数）的绑定，如果直接对原set遍历，会出现无线循环（一边delete一边add造成的循环）
                        const effectToRun = new Set(bucket)
                        effectToRun.forEach((fn) => fn())
                    }

                    return true
                },
            }
        )
        let i = 1
        effect(() => {
            // data.info = '2'
            window.document.querySelector('.test').innerHTML = data.info
            // console.log(data.info)
            // console.log('fn1')
            // effect(() => {
            //     console.log('fn2')
            //     text = data.ok
            // })
            // text = data.info
            // console.log('effect' + i++)
        })

        setTimeout(() => {
            data.info = '3'
        }, 1000)
        // data.ok = false
        function effect(fn) {
            // 加一层，做一些其他操作
            const effectFn = () => {
                clearBucket(effectFn)
                effectStack.push(effectFn)
                fn()
            }
            effectFn.buckets = []
            effectFn()
        }

        function clearBucket(effectFn) {
            for (let index = 0; index < effectFn.buckets.length; index++) {
                const set = effectFn.buckets[index]
                set.delete(effectFn)
            }
            effectFn.buckets.length = 0
        }
    </script>
</html>
